## 문제

https://www.acmicpc.net/problem/1931

### 문제 파악하기

위 문제는 백준 알고리즘 1931 회의실 배정 문제이다.

한 개의 회의실에서 N개의 회의를 진행해야 할 때, 최대한 많은 회의를 진행할 수 있는 개수를 구하는 문제다. 각 회의는 시작 시간과 종료 시간이 주어진다.

> [!NOTE] > **그리디(탐욕법) 접근**: 회의를 최대한 많이 하려면, 빨리 끝나는 회의부터 선택해야 한다.
>
> 핵심 아이디어는 **종료 시간이 빠른 순서로 정렬**하는 것!
>
> - 종료 시간이 빠른 회의를 선택하면 다음 회의를 위한 시간이 최대화됨
> - 종료 시간이 같다면 시작 시간이 빠른 순서로 정렬 (시작=종료인 경우 처리)

## 풀이

### 1. 정렬

```javascript
const meetings = input
  .slice(1)
  .map((item) => item.split(" ").map(Number))
  .sort((a, b) => {
    if (a[1] === b[1]) {
      return a[0] - b[0]; // 종료 시간이 같으면 시작 시간 순
    }
    return a[1] - b[1]; // 종료 시간 순
  });
```

> [!TIP] > **왜 종료 시간이 같을 때 시작 시간도 정렬해야 하나?**
>
> 예: `[1, 2]`와 `[2, 2]` 두 회의가 있을 때
>
> - `[2, 2]`가 먼저 오면: `[2, 2]` 선택 → `[1, 2]`는 선택 불가 (1 < 2)
> - `[1, 2]`가 먼저 오면: `[1, 2]` 선택 → `[2, 2]`도 선택 가능 (2 >= 2)
>
> 시작 시간 순으로 정렬해야 둘 다 선택 가능!

### 2. 그리디 탐색

```javascript
let count = 1;
let doing = meetings[0];

for (let i = 1; i < meetings.length; i++) {
  const [beforeStart, beforeEnd] = doing;
  const [currentStart, currentEnd] = meetings[i];

  if (beforeEnd <= currentStart) {
    count++;
    doing = meetings[i];
  }
}
```

- `doing`: 현재 선택된 회의
- `beforeEnd <= currentStart`: 이전 회의가 끝난 후에 현재 회의가 시작하면 선택 가능
- 선택할 때마다 count 증가하고 doing 갱신

### 3. 예시

```
회의: [[1,4], [3,5], [0,6], [5,7], [3,8], [5,9], [6,10], [8,11], [8,12], [2,13], [12,14]]
종료 시간 순 정렬: [[1,4], [3,5], [0,6], [5,7], [3,8], [5,9], [6,10], [8,11], [8,12], [2,13], [12,14]]

1. [1,4] 선택 → count=1
2. [3,5] 시작(3) < 종료(4) → 불가
3. [0,6] 시작(0) < 종료(4) → 불가
4. [5,7] 시작(5) >= 종료(4) → 선택! count=2
5. [3,8] 시작(3) < 종료(7) → 불가
6. [5,9] 시작(5) < 종료(7) → 불가
7. [6,10] 시작(6) < 종료(7) → 불가
8. [8,11] 시작(8) >= 종료(7) → 선택! count=3
9. [8,12] 시작(8) < 종료(11) → 불가
10. [2,13] 시작(2) < 종료(11) → 불가
11. [12,14] 시작(12) >= 종료(11) → 선택! count=4

결과: 4개
```
