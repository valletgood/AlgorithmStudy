## 문제

https://www.acmicpc.net/problem/12865

### 문제 파악하기

위 문제는 백준 알고리즘 12865 평범한 배낭 문제이다.

N개의 물건이 있고 각각 무게(W)와 가치(V)를 가진다. 배낭 용량 K를 초과하지 않으면서 담을 수 있는 물건들의 **최대 가치 합**을 구하는 문제다.

> [!NOTE] > **0/1 Knapsack 문제**: 각 물건을 담거나(1) 안 담거나(0) 두 가지 선택만 가능하다.
>
> - 물건을 쪼개서 담을 수 없음
> - DP로 해결하는 대표적인 문제

## 풀이

### 1. 1차원 DP 배열

```javascript
const dp = Array(K + 1).fill(0);
```

- `dp[j]`: 용량 j일 때 담을 수 있는 최대 가치
- 2차원 대신 1차원 배열로 **공간 최적화**

### 2. 점화식

```javascript
for (let i = 0; i < N; i++) {
  const [weight, value] = lines[i];
  for (let j = K; j >= weight; j--) {
    dp[j] = Math.max(dp[j], dp[j - weight] + value);
  }
}
```

> [!TIP] > **핵심: 역순으로 순회**
>
> - `dp[j] = max(dp[j], dp[j - weight] + value)`
> - **j를 K부터 weight까지 역순으로** 순회해야 함
>
> **왜 역순인가?**
>
> - 정순이면 같은 물건을 여러 번 사용할 수 있게 됨
> - 예: weight=2일 때, dp[2] 갱신 → dp[4]에서 dp[2] 참조 → 같은 물건 2번 사용
> - 역순이면 아직 갱신 안 된 이전 상태를 참조하므로 1번만 사용

### 3. 결과

```javascript
console.log(dp[K]);
```

- 용량 K일 때의 최대 가치 출력

### 4. 예시

```
N = 4, K = 7
물건: [[6,13], [4,8], [3,6], [5,12]]

무게순 정렬: [[3,6], [4,8], [5,12], [6,13]]

DP 진행:
초기: dp = [0, 0, 0, 0, 0, 0, 0, 0]

물건 [3,6]:
  j=7: dp[7] = max(0, dp[4]+6) = 6
  j=6: dp[6] = max(0, dp[3]+6) = 6
  ...
  j=3: dp[3] = max(0, dp[0]+6) = 6
  dp = [0, 0, 0, 6, 6, 6, 6, 6]

물건 [4,8]:
  j=7: dp[7] = max(6, dp[3]+8) = max(6, 14) = 14
  j=6: dp[6] = max(6, dp[2]+8) = max(6, 8) = 8
  ...
  dp = [0, 0, 0, 6, 8, 8, 8, 14]

... (생략)

최종: dp[7] = 14  (무게 3+4=7, 가치 6+8=14)
```

### 5. 시간/공간 복잡도

- 시간 복잡도: O(N × K)
- 공간 복잡도: O(K) - 1차원 배열 최적화
