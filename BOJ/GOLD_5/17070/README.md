# 파이프 옮기기 1

[백준 17070번: 파이프 옮기기 1](https://www.acmicpc.net/problem/17070)

## 문제 파악하기

N×N 크기의 집에서 파이프를 (1,1)-(1,2) 위치에서 (N,N) 위치까지 옮기는 방법의 수를 구하는 문제입니다. 파이프는 2칸을 차지하며, **가로, 세로, 대각선** 3가지 상태가 있습니다.

> [!NOTE]
> 파이프의 이동 규칙:
>
> - **가로 파이프**: 가로 또는 대각선으로만 이동 가능
> - **세로 파이프**: 세로 또는 대각선으로만 이동 가능
> - **대각선 파이프**: 가로, 세로, 대각선 모두 이동 가능
>
> 대각선으로 이동할 때는 3칸(오른쪽, 아래, 대각선)이 모두 빈 칸이어야 합니다.

## 풀이

이 문제는 **DP(동적 프로그래밍)**으로 해결할 수 있습니다. 각 위치에 파이프가 어떤 상태로 도달할 수 있는지를 저장하면서 경우의 수를 누적합니다.

### 1. DP 배열 정의

```javascript
// dp[i][j][z] z:0 가로, z:1 세로, z:2 대각선
const dp = Array.from({ length: N }, () =>
  Array.from({ length: N }, () => [0, 0, 0])
);
```

- `dp[i][j][0]`: (i, j) 위치에 **가로 상태**로 도달하는 경우의 수
- `dp[i][j][1]`: (i, j) 위치에 **세로 상태**로 도달하는 경우의 수
- `dp[i][j][2]`: (i, j) 위치에 **대각선 상태**로 도달하는 경우의 수

### 2. 초기값 설정

```javascript
dp[0][1][0] = 1;
```

파이프는 처음에 (0,0)-(0,1)에 가로로 놓여있으므로, `dp[0][1][0] = 1`로 초기화합니다.

### 3. 첫 번째 행 처리

```javascript
for (let j = 2; j < N; j++) {
  if (board[0][j] === 1) break;
  dp[0][j][0] = dp[0][j - 1][0];
}
```

첫 번째 행에서는 가로로만 이동 가능하므로, 벽을 만나기 전까지 가로 이동 경우의 수를 누적합니다.

### 4. 점화식

```javascript
for (let i = 1; i < N; i++) {
  for (let j = 2; j < N; j++) {
    if (board[i][j] === 1) continue;
    // 가로: 이전이 가로 또는 대각선
    dp[i][j][0] = dp[i][j - 1][0] + dp[i][j - 1][2];
    // 세로: 이전이 세로 또는 대각선
    dp[i][j][1] = dp[i - 1][j][2] + dp[i - 1][j][1];
    // 대각선: 이전이 가로, 세로, 대각선 모두 가능 (주변 벽 체크 필요)
    if (board[i - 1][j] === 0 && board[i][j - 1] === 0) {
      dp[i][j][2] =
        dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] + dp[i - 1][j - 1][2];
    }
  }
}
```

> [!TIP]
> 대각선 이동 시 **3칸 체크**가 핵심입니다!
>
> - 현재 위치 `board[i][j]`
> - 위쪽 `board[i-1][j]`
> - 왼쪽 `board[i][j-1]`
>
> 이 세 칸이 모두 빈 칸이어야 대각선 이동이 가능합니다.

### 5. 결과 출력

```javascript
const [a, b, c] = dp[N - 1][N - 1];
console.log(a + b + c);
```

(N-1, N-1) 위치에 가로, 세로, 대각선 상태로 도달하는 모든 경우의 수를 합산하여 출력합니다.
