# 내리막 길

[백준 1520번: 내리막 길](https://www.acmicpc.net/problem/1520)

## 문제 파악하기

N×M 지도에서 (0,0)에서 (N-1,M-1)까지 이동하는 경로의 수를 구하는 문제입니다. 단, **현재 높이보다 낮은 칸으로만** 이동할 수 있습니다.

> [!NOTE]
> 단순 DFS로 풀면 같은 칸을 여러 번 방문하게 되어 시간 초과가 발생합니다.
>
> **DFS + 메모이제이션(DP)**을 사용하면 각 칸에서 목적지까지 가는 경로 수를 저장해두고 재사용할 수 있어 효율적입니다.

## 풀이

이 문제는 **DFS + 메모이제이션**으로 해결할 수 있습니다.

### 1. DP 배열 초기화

```javascript
let dp = Array.from({ length: N }, () => Array(M).fill(-1));
```

- `dp[x][y] = -1`: 아직 방문하지 않음
- `dp[x][y] = 0`: 방문했지만 목적지까지 도달 불가
- `dp[x][y] > 0`: (x, y)에서 목적지까지 가는 경로 수

> [!TIP] > **-1로 초기화하는 이유**가 중요합니다!
>
> 0으로 초기화하면 "방문 안 함"과 "경로 없음"을 구분할 수 없습니다. -1로 초기화하면 방문 여부를 명확하게 판단할 수 있습니다.

### 2. DFS 함수

```javascript
const dfs = (x, y) => {
  // 목적지 도착
  if (x === N - 1 && y === M - 1) return 1;
  // 이미 계산된 값이 있으면 반환 (메모이제이션)
  if (dp[x][y] !== -1) return dp[x][y];

  dp[x][y] = 0; // 방문 표시
  const h = board[x][y];

  for (const [dx, dy] of dirs) {
    const nx = x + dx;
    const ny = y + dy;
    if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
    // 현재 높이보다 낮은 칸으로만 이동
    if (board[nx][ny] < h) {
      dp[x][y] += dfs(nx, ny);
    }
  }
  return dp[x][y];
};
```

### 동작 원리

1. 현재 위치가 목적지면 1 반환 (경로 1개 찾음)
2. 이미 계산된 값이 있으면 바로 반환 (중복 계산 방지)
3. 4방향 탐색하면서 현재보다 낮은 칸으로 이동
4. 각 방향에서 반환된 경로 수를 합산하여 저장

### 3. 결과 출력

```javascript
console.log(dfs(0, 0));
```

(0, 0)에서 시작하여 목적지까지 가는 모든 경로의 수를 출력합니다.
