# 동전 1

[백준 2293번: 동전 1](https://www.acmicpc.net/problem/2293)

## 문제 파악하기

N가지 종류의 동전을 사용하여 **K원을 만드는 경우의 수**를 구하는 문제입니다.

### 조건

- 각 동전은 무한히 사용 가능
- 순서가 다른 것은 같은 경우로 취급 (조합)

> [!NOTE]
> 이 문제는 **메모리 제한이 4MB**로 매우 작습니다.
> JavaScript의 경우 런타임 오버헤드로 메모리 초과가 발생할 수 있어 Python으로 풀이했습니다.

## 풀이

**1차원 DP** 로 해결합니다.

### 핵심 아이디어

`dp[j]` = j원을 만드는 경우의 수

동전을 하나씩 추가하면서 해당 동전을 사용하는 경우를 누적합니다.

### 1. DP 배열 초기화

```python
dp = [0] * (K + 1)
dp[0] = 1
```

- `dp[0] = 1`: 0원을 만드는 방법은 1가지 (아무 동전도 안 쓰기)

### 2. 동전별로 경우의 수 누적

```python
for i in range(N):
    for j in range(coins[i], K + 1):
        dp[j] = dp[j] + dp[j - coins[i]]
```

> [!TIP] > **루프 순서가 중요합니다!**
>
> - 동전 → 금액 순서: **조합** (순서 무시, 이 문제)
> - 금액 → 동전 순서: **순열** (순서 구분)

### 점화식 이해

```
dp[j] += dp[j - coin]
```

- `dp[j]`: 기존에 j원을 만드는 경우의 수
- `dp[j - coin]`: 현재 동전을 하나 더 써서 j원을 만드는 경우의 수

## 동작 예시

```
동전: [1, 2, 5], K = 10

초기: dp = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

동전 1 적용 후:
dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

동전 2 적용 후:
dp = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6]

동전 5 적용 후:
dp = [1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 10]

결과: dp[10] = 10
```

## 핵심 정리

| 구분      | 설명                      |
| --------- | ------------------------- |
| dp[j]     | j원을 만드는 경우의 수    |
| 바깥 루프 | 동전 종류                 |
| 안쪽 루프 | coins[i] ~ K              |
| 점화식    | dp[j] += dp[j - coins[i]] |

### 왜 1차원 DP인가?

- 2차원: `dp[i][j]` = i번째 동전까지 써서 j원 만들기 → 메모리 O(N × K)
- 1차원: 이전 동전의 결과를 덮어쓰면서 갱신 → 메모리 O(K)

### 시간 복잡도

- 동전 N개 × 금액 K
- **O(N × K)**

### 공간 복잡도

- 1차원 DP 배열
- **O(K)**
