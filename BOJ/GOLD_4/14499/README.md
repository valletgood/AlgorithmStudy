# 주사위 굴리기

[백준 14499번: 주사위 굴리기](https://www.acmicpc.net/problem/14499)

## 문제 파악하기

N×M 지도 위에서 주사위를 굴리며, 각 명령 후 **주사위 윗면의 값**을 출력하는 시뮬레이션 문제입니다.

### 규칙

1. 주사위를 굴렸을 때 이동한 칸의 수가 0이면 → 주사위 바닥면 수를 칸에 복사
2. 이동한 칸의 수가 0이 아니면 → 칸의 수를 주사위 바닥면에 복사하고 칸은 0으로
3. 지도 밖으로 나가는 명령은 무시 (출력도 안 함)

> [!NOTE] > **핵심**: 주사위의 6면을 배열로 관리하고, 굴릴 때마다 면의 값을 적절히 교환합니다.

## 풀이

### 1. 주사위 상태 정의

```javascript
let dice = [0, 0, 0, 0, 0, 0];
// 0번: 윗면, 1번: 앞면, 2번: 오른쪽, 3번: 왼쪽, 4번: 뒷면, 5번: 바닥
```

초기 상태: 모든 면이 0

### 2. 방향별 굴리기

#### 동쪽 (오른쪽으로 굴리기)

```javascript
const moveRight = () => {
  if (sy + 1 >= M) return; // 범위 체크
  sy += 1;
  const floor = dice[5];
  const right = dice[2];
  const left = dice[3];
  const top = dice[0];
  dice[0] = left; // 왼쪽 → 윗면
  dice[2] = top; // 윗면 → 오른쪽
  dice[5] = right; // 오른쪽 → 바닥
  dice[3] = floor; // 바닥 → 왼쪽
  // ... 보드와 상호작용
};
```

#### 서쪽 (왼쪽으로 굴리기)

```javascript
dice[3] = top; // 윗면 → 왼쪽
dice[0] = right; // 오른쪽 → 윗면
dice[5] = left; // 왼쪽 → 바닥
dice[2] = floor; // 바닥 → 오른쪽
```

#### 북쪽 (위로 굴리기)

```javascript
dice[1] = top; // 윗면 → 앞면
dice[0] = back; // 뒷면 → 윗면
dice[4] = floor; // 바닥 → 뒷면
dice[5] = front; // 앞면 → 바닥
```

#### 남쪽 (아래로 굴리기)

```javascript
dice[1] = floor; // 바닥 → 앞면
dice[0] = front; // 앞면 → 윗면
dice[4] = top; // 윗면 → 뒷면
dice[5] = back; // 뒷면 → 바닥
```

### 3. 보드와 상호작용

```javascript
if (board[sx][sy] !== 0) {
  dice[5] = board[sx][sy]; // 칸의 수 → 주사위 바닥
  board[sx][sy] = 0; // 칸은 0으로
} else {
  board[sx][sy] = dice[5]; // 주사위 바닥 → 칸에 복사
}
answer.push(dice[0]); // 윗면 출력
```

> [!TIP] > **면 교환 패턴**
>
> - 동서 이동: 윗면, 바닥, 왼쪽, 오른쪽이 순환
> - 남북 이동: 윗면, 바닥, 앞면, 뒷면이 순환
> - 앞/뒤, 좌/우는 서로 반대 면이 아님에 주의!

## 주사위 전개도

```
    [뒷면(4)]
[왼쪽(3)][윗면(0)][오른쪽(2)]
    [앞면(1)]
    [바닥(5)]
```

## 핵심 정리

| 방향 | 순환하는 면                 | 고정되는 면  |
| ---- | --------------------------- | ------------ |
| 동   | 윗면 → 오른쪽 → 바닥 → 왼쪽 | 앞면, 뒷면   |
| 서   | 윗면 → 왼쪽 → 바닥 → 오른쪽 | 앞면, 뒷면   |
| 북   | 윗면 → 앞면 → 바닥 → 뒷면   | 왼쪽, 오른쪽 |
| 남   | 윗면 → 뒷면 → 바닥 → 앞면   | 왼쪽, 오른쪽 |

### 시간 복잡도

- 명령 수 K에 대해 각 명령을 O(1)에 처리
- **O(K)**
