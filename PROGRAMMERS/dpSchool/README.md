## 문제

https://school.programmers.co.kr/learn/courses/30/lessons/42898

### 문제 파악하기

위 문제는 프로그래머스 등굣길 문제이다.

m x n 크기의 격자에서 집(1, 1)에서 학교(m, n)까지 가는 최단 경로의 개수를 구하는 문제다. 단, 물웅덩이가 있는 칸은 지나갈 수 없으며, 오른쪽과 아래쪽으로만 이동할 수 있다.

<aside>
💡

이 문제는 동적 프로그래밍(DP)으로 해결한다. 각 칸에 도달할 수 있는 경로의 수는 위쪽 칸과 왼쪽 칸에서 올 수 있는 경로의 수를 합한 값이다.

</aside>

## 풀이

### 1. DP 배열 초기화 및 물웅덩이 표시

```javascript
let dp = Array.from({ length: n }, () => Array(m).fill(0));

for (let i = 0; i < puddles.length; i++) {
  const [x, y] = puddles[i];
  dp[y - 1][x - 1] = -1;
}

dp[0][0] = 1;
```

- n x m 크기의 DP 배열을 0으로 초기화한다.
- 물웅덩이 위치는 `-1`로 표시하여 지나갈 수 없음을 나타낸다.
- 시작점 (0, 0)은 경로가 1개이므로 `1`로 설정한다.

<aside>
💡

문제에서 좌표가 (x, y) 형태로 주어지므로 배열 인덱스로 변환할 때 `dp[y-1][x-1]`로 접근한다.

</aside>

### 2. 첫 번째 행과 열 초기화

```javascript
for (let j = 1; j < m; j++) {
  if (dp[0][j - 1] === -1 || dp[0][j] === -1) {
    dp[0][j] = -1;
  } else {
    dp[0][j] = 1;
  }
}

for (let i = 1; i < n; i++) {
  if (dp[i][0] === -1 || dp[i - 1][0] === -1) {
    dp[i][0] = -1;
  } else {
    dp[i][0] = 1;
  }
}
```

- 첫 번째 행은 오른쪽으로만 이동 가능하므로, 이전 칸이 물웅덩이면 그 이후 칸들은 도달 불가능하다.
- 첫 번째 열도 아래쪽으로만 이동 가능하므로 동일한 로직을 적용한다.

<aside>
💡

물웅덩이가 있거나 이전 칸이 이미 막혀있으면 `-1`로 표시하고, 그렇지 않으면 경로가 1개이므로 `1`로 설정한다.

</aside>

### 3. DP 점화식 적용

```javascript
for (let i = 1; i < n; i++) {
  for (let j = 1; j < m; j++) {
    if (dp[i][j] === -1) {
      continue;
    }
    if (dp[i - 1][j] === -1 && dp[i][j - 1] === -1) {
      dp[i][j] = 0;
    } else if (dp[i - 1][j] === -1) {
      dp[i][j] = dp[i][j - 1] % MOD;
    } else if (dp[i][j - 1] === -1) {
      dp[i][j] = dp[i - 1][j] % MOD;
    } else {
      dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;
    }
  }
}
```

- 현재 칸이 물웅덩이면 건너뛴다.
- 위쪽과 왼쪽 모두 물웅덩이면 도달할 수 없으므로 `0`으로 설정한다.
- 한쪽만 물웅덩이면 다른 쪽의 경로 수만 가져온다.
- 둘 다 유효하면 두 경로 수를 합산한다.

<aside>
💡

경로 수가 매우 커질 수 있으므로 매번 `1,000,000,007`로 나눈 나머지를 저장한다.

</aside>

### 4. 결과 반환

```javascript
return dp[n - 1][m - 1];
```

- 학교 위치인 (n-1, m-1)에 저장된 값이 최단 경로의 개수이다.
